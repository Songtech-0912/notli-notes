use anyhow::Result as AnyhowResult;
use colored::Colorize;
use log;
use project_root::get_project_root;
use pulldown_cmark::{html, Options, Parser};
use regex::Regex;
use simple_logger;
use std::fs;
use std::io::Read;
use std::io::Write;
use std::path::PathBuf;

/*
 * Things to do:
 * 1. (DONE) check that markdown files exist in src directory
 * 2. (DONE) convert each to HTML
 * 3. (DONE) convert the maths equations in each to katex equivalent
 * 4. (DONE) convert the image link url to the correct ones
 * 5. (DONE) wrap each with the appropriate tags for Tailwind typography
 * 6. (DONE) write to the appropriate HTML output file to pages/
 * */

// Please forgive the messiness of this function, I cannot do
// anything else, I will descend into madness once again if
// I use another rust templating crate. The monster of unsafety
// awaits, the day of doom is coming, and my code will cry...
fn template(title: &str, contents: &str) -> AnyhowResult<String> {
    let result_str = format!(
        r#"<!DOCTYPE html>
<!--Please do not edit this file manually,
    it is auto-generated by Notli. Refer to
    the markdown version in src/ to make changes
  -->
<html>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>{}</title>

        <!--Tailwind typography-->
        <link rel="stylesheet" href="../css/tailwind.output.css">

        <!--KaTeX stylesheet-->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

        <!--KaTeX script-->
        <script src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

        <!--KaTeX auto-render extension script-->
        <script src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
    </head>

  <body class="w-full px-6 py-12 bg-gradient-to-r from-fuchsia-100 via-gray-50 to-teal-100">
    <article class="prose md:prose-md lg:prose-lg mx-auto my-8">
        <!--contents here generated by Notli-->
        {}
    </article>

    <!--KaTeX auto-render extension setup-->
    <script src="common/setup.js"></script>
  </body>
</html>"#,
        title, contents
    );
    Ok(result_str)
}

fn get_rootdir() -> AnyhowResult<PathBuf> {
    let notli_root = get_project_root()?;
    Ok(notli_root)
}

fn get_srcdir() -> AnyhowResult<PathBuf> {
    let rootdir = get_rootdir().unwrap();
    let notli_src = rootdir.parent().unwrap().join("src");
    log::info!(
        "Found Notli sources at {}",
        &notli_src.to_str().unwrap().green()
    );
    Ok(notli_src.to_path_buf())
}

fn get_outputdir() -> AnyhowResult<PathBuf> {
    let rootdir = get_rootdir().unwrap();
    let notli_output = rootdir.parent().unwrap().join("pages");
    log::info!(
        "Found Notli output folder at {}",
        notli_output.to_str().unwrap().green()
    );
    Ok(notli_output)
}

fn replace_image_paths(text: String) -> AnyhowResult<String> {
    // Takes a string and replaces all $$...$$ with katex
    // this ONLY replaces block maths ($$...$$) not inline
    let re = Regex::new(r"../images")?;
    let output = re.replace_all(&text, "./images").to_string();
    Ok(output)
}

fn main() -> AnyhowResult<()> {
    simple_logger::init()?;
    log::info!("Starting application");
    let src_dir = get_srcdir()?;
    let output_dir = get_outputdir()?;
    let md_files = fs::read_dir(&src_dir)?;
    // Thanks: https://users.rust-lang.org/t/filtering-file-names-with-ends-with/16939/5
    let md_files_iter = md_files
        .filter_map(|entry| entry.ok())
        .filter(|f| if let Some(e) = f.path().extension() { e == "md" } else {false})
        .collect::<Vec<fs::DirEntry>>();
    for md_file in md_files_iter {
        let path = &md_file.path();
        let filename_no_stem = &path.file_stem().unwrap().to_str().unwrap();
        log::info!("Found Notli file: {}", &path.to_str().unwrap().green());
        let mut md_input = fs::File::open(&path)?;
        let mut md_contents = String::new();
        md_input.read_to_string(&mut md_contents)?;
        let mut pulldown_options = Options::empty();
        // We want to enable certain features not in
        // standard commonmark spec
        pulldown_options.insert(Options::ENABLE_STRIKETHROUGH);
        pulldown_options.insert(Options::ENABLE_TABLES);
        pulldown_options.insert(Options::ENABLE_HEADING_ATTRIBUTES);
        let parser = Parser::new_ext(&md_contents, pulldown_options);
        let mut html_output = String::new();
        html::push_html(&mut html_output, parser);
        log::info!(
            "Markdown conversion successfully passed for: {}",
            format!("{}.md", &filename_no_stem).green()
        );
        // Change image relative paths to work
        html_output = replace_image_paths(html_output)?;
        // Wrap html in template
        let templated_html = template(&filename_no_stem, &html_output)?;
        // Create final html in pages/
        let html_output_name = format!("{}.html", &filename_no_stem);
        let html_output_path = &output_dir.join(&html_output_name);
        log::info!(
            "Creating output file {}",
            &html_output_path.to_str().unwrap().green()
        );
        let output_file = fs::File::create(&html_output_path)?;
        write!(&output_file, "{}", templated_html)?;
        log::info!(
            "{}",
            format!("Finished converting '{}'", &filename_no_stem).blue()
        );
    }
    Ok(())
}
